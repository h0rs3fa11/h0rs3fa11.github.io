---
title: 2017看雪CTF leifeiCM
date: 2017-06-10 22:16:01
tags: [reverse,ctf]
---
这个CM无壳，就是算法比较绕人，用OD载入之后输入987654321测试
<!--more-->
## 计算
```asm
0040104E  |.  E8 7D0A0000   call    00401AD0                         ;  input
00401053  |.  8D7C24 20     lea     edi, dword ptr [esp+20]
00401057  |.  83C9 FF       or      ecx, FFFFFFFF
0040105A  |.  33C0          xor     eax, eax
0040105C  |.  83C4 18       add     esp, 18
0040105F  |.  F2:AE         repne   scas byte ptr es:[edi]
00401061  |.  F7D1          not     ecx
00401063  |.  83C1 FE       add     ecx, -2
00401066  |.  83F9 08       cmp     ecx, 8                           ;  >=8
00401069  |.  0F8C 0B020000 jl      0040127A
0040106F  |.  83F9 14       cmp     ecx, 14                          ;  <=20
00401072  |.  0F8F 02020000 jg      0040127A
00401078  |.  33F6          xor     esi, esi
0040107A  |.  33D2          xor     edx, edx
0040107C  |.  85C9          test    ecx, ecx
0040107E  |.  88440C 08     mov     byte ptr [esp+ecx+8], al
00401082  |.  7E 28         jle     short 004010AC
```
长度在8~20之间
```asm
00401084  |> /8A4414 08     /mov     al, byte ptr [esp+edx+8]
00401088  |. |3C 30         |cmp     al, 30
0040108A  |. |7E 04         |jle     short 00401090
0040108C  |. |3C 39         |cmp     al, 39
0040108E  |. |7E 01         |jle     short 00401091
00401090  |> |46            |inc     esi
00401091  |> |42            |inc     edx
00401092  |. |3BD1          |cmp     edx, ecx
00401094  |.^\7C EE         \jl      short 00401084
00401096  |.  85F6          test    esi, esi
00401098  |.  74 12         je      short 004010AC
0040109A  |.  68 74904000   push    00409074                         ;  key format error...\n
0040109F  |.  E8 3C0B0000   call    00401BE0
```
全是数字，并且不为0
```asm
004010AC  |> \8D8C24 0C0100>lea     ecx, dword ptr [esp+10C]
004010B3  |.  E8 08020000   call    004012C0                         ;  初始化
```
初始化一个对象
继续往下，跟进4014E0
```asm
004014FF  |. /7E 2E         jle     short 0040152F                   ;  <=
00401501  |> |8A042E        /mov     al, byte ptr [esi+ebp]
00401504  |. |3C 30         |cmp     al, 30
00401506  |. |7C 22         |jl      short 0040152A
00401508  |. |3C 39         |cmp     al, 39
0040150A  |. |7F 1E         |jg      short 0040152A
0040150C  |. |0FBEC0        |movsx   eax, al
0040150F  |. |83E8 30       |sub     eax, 30                         ;  转十进制
00401512  |. |74 16         |je      short 0040152A
00401514  |. |85F6          |test    esi, esi
00401516  |. |74 0A         |je      short 00401522
00401518  |. |8BCE          |mov     ecx, esi
0040151A  |> |8D0480        |/lea     eax, dword ptr [eax+eax*4]     ;  eax*10
0040151D  |. |03C0          ||add     eax, eax
0040151F  |. |49            ||dec     ecx
00401520  |.^|75 F8         |\jnz     short 0040151A
00401522     |50            push    eax
00401523  |. |8BCB          |mov     ecx, ebx
00401525  |. |E8 56000000   |call    00401580
0040152A  |> |46            |inc     esi
0040152B  |. |3BF7          |cmp     esi, edi
0040152D  |.^|7C D2         \jl      short 00401501
0040152F  |> \8BCB          mov     ecx, ebx
00401531  |.  E8 3A040000   call    00401970                         ;  检查位数
```
转十进制数
运行到call 401730,跟进
F8单步走，之前的call就大致浏览一下，运行到call 401540，跟进去看看
```asm
00401540  /$  56            push    esi
00401541  |.  8B7424 08     mov     esi, dword ptr [esp+8]
00401545  |.  33D2          xor     edx, edx
00401547  |.  8B46 04       mov     eax, dword ptr [esi+4]           ;  读取长度
0040154A  |.  85C0          test    eax, eax
0040154C  |.  8941 04       mov     dword ptr [ecx+4], eax
0040154F  |.  7E 28         jle     short 00401579
00401551  |.  53            push    ebx
00401552  |.  55            push    ebp
00401553  |.  57            push    edi
00401554  |.  8BFE          mov     edi, esi
00401556  |.  8D81 08100000 lea     eax, dword ptr [ecx+1008]
0040155C  |.  2BF9          sub     edi, ecx
0040155E  |>  8B1C07        /mov     ebx, dword ptr [edi+eax]
00401561  |.  8B28          |mov     ebp, dword ptr [eax]
00401563  |.  42            |inc     edx
00401564  |.  83C0 04       |add     eax, 4
00401567 >|.  8B5C9E 08     |mov     ebx, dword ptr [esi+ebx*4+8]    ;  读取数字
0040156B >|.  895CA9 08     |mov     dword ptr [ecx+ebp*4+8], ebx
0040156F  |.  8B59 04       |mov     ebx, dword ptr [ecx+4]
00401572  |.  3BD3          |cmp     edx, ebx
00401574  |.^ 7C E8         \jl      short 0040155E
00401576  |.  5F            pop     edi
00401577  |.  5D            pop     ebp
00401578  |.  5B            pop     ebx
00401579  |>  5E            pop     esi
0040157A  \.  C2 0400       retn    4
```
这里会读取我们输入的数字，而且通过ida交叉引用可知后面还会调用几次这个读取的过程，于是可以设置一个条件断点记录这里读取的值。
在00401567记录
![](/image/leifeicm1.png)
在40156B记录
![](/image/leifeicm2.png)
![](/image/leifeicm3.png)
然后在retn的地方下个断点，直接运行过去
打开Log窗口（之前已经清空）
![](/image/leifeicm4.png)
可以看到读取输入数字的过程
接下来继续单步运行
```asm
0040179C          |.  E8 9FFDFFFF   |call    00401540                        ;  读取
004017A1          |.  57            |push    edi
004017A2          |.  8D4C24 14     |lea     ecx, dword ptr [esp+14]
004017A6          |.  E8 B5FEFFFF   |call    00401660
004017AB          |.  56            |push    esi
004017AC          |.  8D4C24 14     |lea     ecx, dword ptr [esp+14]
004017B0          |.  E8 2BFFFFFF   |call    004016E0                        ;  乘法 num
```
跟进004017B0 call 004016E0
```asm
004016FF          |> /8B06          /mov     eax, dword ptr [esi]
00401701          |. |83C6 04       |add     esi, 4
00401704          |. |8B5C81 08     |mov     ebx, dword ptr [ecx+eax*4+8]
00401708 x        |. |8D4481 08     |lea     eax, dword ptr [ecx+eax*4+8]
0040170C y        |. |0FAFDF        |imul    ebx, edi                        ;  9*num
0040170F x*y      |. |8918          |mov     dword ptr [eax], ebx
00401711          |. |8B41 04       |mov     eax, dword ptr [ecx+4]
00401714          |. |42            |inc     edx
00401715          |. |3BD0          |cmp     edx, eax
00401717          |.^\7C E6         \jl      short 004016FF
```
这里是一个乘法的实现，并且之后还会调用。这里是之前传入的参数9分别乘上输入的数字，同样设置条件记录一下
![](/image/leifeicm5.png)
00401708记录ebx，0040170C记录edi，0040170F记录ebx
在0040171B设置断点，运行跳过循环，记录内容如下：
```
00401708  COND: x = 00000009
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000051
00401708  COND: x = 00000008
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000048
00401708  COND: x = 00000007
0040170C  COND: y = 00000009
0040170F  COND: x*y = 0000003F
00401708  COND: x = 00000006
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000036
00401708  COND: x = 00000005
0040170C  COND: y = 00000009
0040170F  COND: x*y = 0000002D
00401708  COND: x = 00000004
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000024
00401708  COND: x = 00000003
0040170C  COND: y = 00000009
0040170F  COND: x*y = 0000001B
00401708  COND: x = 00000002
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000012
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
0040171B  断点位于 2-lelfei.0040171B
```
然后进入0040171B的这个call看看
```asm
00401719          |.  5E            pop     esi
0040171A          |.  5B            pop     ebx
0040171B          |>  E8 50020000   call    00401970                         ;  123...9*9=111....1 完成进位
00401720          |.  33C0          xor     eax, eax
00401722          |.  5F            pop     edi
00401723          |.  C2 0400       retn    4
```
进去之后可以看到有一个除法取余的操作，同样可以设置条件断点跟踪一下
![](/image/leifeicm6.png)
分别记录eax、edx的值
运行过后记录如下
```
004019BE  COND: eax = 00000051
004019C0  COND: eax mod 10 = 00000001
004019BE  COND: eax = 00000050
004019C0  COND: eax mod 10 = 00000000
004019BE  COND: eax = 00000047
004019C0  COND: eax mod 10 = 00000001
004019BE  COND: eax = 0000003D
004019C0  COND: eax mod 10 = 00000001
004019BE  COND: eax = 00000033
004019C0  COND: eax mod 10 = 00000001
004019BE  COND: eax = 00000029
004019C0  COND: eax mod 10 = 00000001
004019BE  COND: eax = 0000001F
004019C0  COND: eax mod 10 = 00000001
```
这里得分析一下，刚开始eax=0x51=81，通过之前的记录这个值就是99的值；然后eax=0x50，这个值即为89+8=0x50，加上的这个8就是99的进位，再分析几个就能知道，刚才那个call分别让输入的数字乘9，而这里则完成了进位，**实现的就是1234567899的操作**。这个call在加法中也会用于进位。

出来之后下面是
```asm
004017C1          |.  E8 1AFEFFFF   |call    004015E0                        ;  +
跟进去看一下
00401634          |.  8B10          |mov     edx, dword ptr [eax]
00401636          |.  8B2C07        |mov     ebp, dword ptr [edi+eax]
00401639          |.  8B6CAE 08     |mov     ebp, dword ptr [esi+ebp*4+8]
0040163D a        |.  8D5491 08     |lea     edx, dword ptr [ecx+edx*4+8]
00401641 b        |.  012A          |add     dword ptr [edx], ebp            ;  加法
00401643 edx>400  |>  8B5424 10     |mov     edx, dword ptr [esp+10]
00401647          |.  43            |inc     ebx
00401648          |.  83C0 04       |add     eax, 4
0040164B          |.  3BDA          |cmp     ebx, edx
0040164D          |.^ 7C BE         \jl      short 0040160D
0040164F          |.  5F            pop     edi
00401650          |.  5D            pop     ebp
00401651          |>  E8 1A030000   call    00401970
00401656          |.  5E            pop     esi
00401657          |.  5B            pop     ebx
00401658          |.  59            pop     ecx
00401659          \.  C2 0400       retn    4
```
这里有一个加法的操作，而且同样后面还会调用（经过跟踪这里暂时不会调用加法），于是还是设置一个条件记录断点
分别记录ebp、dword ptr [edx]、条件edx>400的dword ptr [edx]，然后运行到retn
此时记录窗口暂时未记下有用的记录
然后继续直接运行到retn
```
0401567  COND: adress = 0012CDD0
0040156B  COND: value = 00000001
00401567  COND: adress = 0012C9C8
0040156B  COND: value = 00000000
00401567  COND: adress = 0012C530
0040156B  COND: value = 00000001
00401567  COND: adress = 0012C0B4
0040156B  COND: value = 00000001
00401567  COND: adress = 0012C044
0040156B  COND: value = 00000001
00401567  COND: adress = 0012C664
0040156B  COND: value = 00000001
00401567  COND: adress = 0012CB20
0040156B  COND: value = 00000001
00401567  COND: adress = 0012CAB8
0040156B  COND: value = 00000001
00401567  COND: adress = 0012C764
0040156B  COND: value = 00000001
00401567  COND: adress = 0012CF58
0040156B  COND: value = 00000001
0040181E  断点位于 2-lelfei.0040181E
```
可见读取了1234567899的结果，然后call 401730就分析完了，作用就是1234567899=1111111101
```asm
004010E9          |.  E8 42060000   call    00401730                         ;  123456789*9=1111111101
004010EE          |.  8D8C24 0C0100>lea     ecx, dword ptr [esp+10C]
004010F5          |.  E8 B6010000   call    004012B0                         ;  nothing
004010FA          |>  8D5424 08     /lea     edx, dword ptr [esp+8]
004010FE          |.  8D8C24 1C2100>|lea     ecx, dword ptr [esp+211C]
00401105          |.  52            |push    edx
00401106          |.  E8 45020000   |call    00401350
0040110B          |.  8D8424 1C2100>|lea     eax, dword ptr [esp+211C]
00401112          |.  8D8C24 0C0100>|lea     ecx, dword ptr [esp+10C]
00401119          |.  50            |push    eax
0040111A          |.  C68424 384100>|mov     byte ptr [esp+4138], 1
00401122          |.  E8 19070000   |call    00401840
00401127          |.  6A 09         |push    9
00401129          |.  8D8C24 100100>|lea     ecx, dword ptr [esp+110]
00401130          |.  8BF0          |mov     esi, eax
00401132          |.  E8 F9050000   |call    00401730
00401137          |.  8D8C24 0C0100>|lea     ecx, dword ptr [esp+10C]
0040113E          |.  03F0          |add     esi, eax
00401140          |.  E8 6B010000   |call    004012B0
00401145          |.  85F6          |test    esi, esi
00401147          |.  0F85 C8000000 |jnz     00401215
0040114D          |.  8D8C24 0C0100>|lea     ecx, dword ptr [esp+10C]
00401154          |.  E8 47020000   |call    004013A0
00401159          |.  25 01000080   |and     eax, 80000001
0040115E          |.  79 05         |jns     short 00401165
```
接下来的几个call可以直接通过记录窗口来分析了，在401147设置断点，运行过来，此时log窗口已经记录了很多，就从开始慢慢分析
```
00401567  COND: adress = 00128514
0040156B  COND: value = 00000001
00401567  COND: adress = 001286AC
0040156B  COND: value = 00000000
00401567  COND: adress = 001288B8
0040156B  COND: value = 00000001
00401567  COND: adress = 00128DDC
0040156B  COND: value = 00000001
00401567  COND: adress = 00128D94
0040156B  COND: value = 00000001
00401567  COND: adress = 001286D8
0040156B  COND: value = 00000001
00401567  COND: adress = 0012811C
0040156B  COND: value = 00000001
00401567  COND: adress = 0012850C
0040156B  COND: value = 00000001
00401567  COND: adress = 001288B0
0040156B  COND: value = 00000001
00401567  COND: adress = 0012816C
0040156B  COND: value = 00000001
00401567  COND: adress = 00124948
0040156B  COND: value = 00000001
00401567  COND: adress = 00124018
0040156B  COND: value = 00000000
00401567  COND: adress = 00124D98
0040156B  COND: value = 00000001
00401567  COND: adress = 00123F28
0040156B  COND: value = 00000001
00401567  COND: adress = 00124540
0040156B  COND: value = 00000001
00401567  COND: adress = 00124420
0040156B  COND: value = 00000001
00401567  COND: adress = 00124CBC
0040156B  COND: value = 00000001
00401567  COND: adress = 001247E8
0040156B  COND: value = 00000001
00401567  COND: adress = 00123F1C
0040156B  COND: value = 00000001
00401567  COND: adress = 00123DE0
0040156B  COND: value = 00000001
```
这里读取了 1111111101 1111111101
```
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
00401708  COND: x = 00000000
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000000
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
00401708  COND: x = 00000001
0040170C  COND: y = 00000009
0040170F  COND: x*y = 00000009
```
这里是1111111101*9=9999999909 (9是个位，即输入的第一位)
```
00401567  COND: adress = 00128514
0040156B  COND: value = 00000009
00401567  COND: adress = 001286AC
0040156B  COND: value = 00000000
00401567  COND: adress = 001288B8
0040156B  COND: value = 00000009
00401567  COND: adress = 00128DDC
0040156B  COND: value = 00000009
00401567  COND: adress = 00128D94
0040156B  COND: value = 00000009
00401567  COND: adress = 001286D8
0040156B  COND: value = 00000009
00401567  COND: adress = 0012811C
0040156B  COND: value = 00000009
00401567  COND: adress = 0012850C
0040156B  COND: value = 00000009
00401567  COND: adress = 001288B0
0040156B  COND: value = 00000009
00401567  COND: adress = 0012816C
0040156B  COND: value = 00000009
```
读取9999999909
```
00401567  COND: adress = 00128514
0040156B  COND: value = 00000001
00401567  COND: adress = 001286AC
0040156B  COND: value = 00000000
00401567  COND: adress = 001288B8
0040156B  COND: value = 00000001
00401567  COND: adress = 00128DDC
0040156B  COND: value = 00000001
00401567  COND: adress = 00128D94
0040156B  COND: value = 00000001
00401567  COND: adress = 001286D8
0040156B  COND: value = 00000001
00401567  COND: adress = 0012811C
0040156B  COND: value = 00000001
00401567  COND: adress = 0012850C
0040156B  COND: value = 00000001
00401567  COND: adress = 001288B0
0040156B  COND: value = 00000001
00401567  COND: adress = 0012816C
0040156B  COND: value = 00000001
00401567  COND: adress = 00124C80
0040156B  COND: value = 00000000
00401567  COND: adress = 00123F5C
0040156B  COND: value = 00000001
00401567  COND: adress = 00124D08
0040156B  COND: value = 00000000
00401567  COND: adress = 00123E70
0040156B  COND: value = 00000001
00401567  COND: adress = 00124858
0040156B  COND: value = 00000001
00401567  COND: adress = 00124BF4
0040156B  COND: value = 00000001
00401567  COND: adress = 00124608
0040156B  COND: value = 00000001
00401567  COND: adress = 0012453C
0040156B  COND: value = 00000001
00401567  COND: adress = 001241A0
0040156B  COND: value = 00000001
00401567  COND: adress = 0012497C
0040156B  COND: value = 00000001
00401567  COND: adress = 00123E84
0040156B  COND: value = 00000001
```
读取11111111010 1111111101
```
00401708  COND: x = 00000000
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000000
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
00401708  COND: x = 00000000
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000000
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
00401708  COND: x = 00000001
0040170C  COND: y = 00000008
0040170F  COND: x*y = 00000008
```
11111111010*8=88888888080
这里8是输入的第二位

(省略记录文件)
接下来读取88888888080
```
0040163D  COND: a = 00000000
00401641  COND: b = 00000009
00401643  COND: a+b = 00000009
0040163D  COND: a = 00000008
00401641  COND: b = 00000000
00401643  COND: a+b = 00000008
0040163D  COND: a = 00000000
00401641  COND: b = 00000009
00401643  COND: a+b = 00000009
0040163D  COND: a = 00000008
00401641  COND: b = 00000009
00401643  COND: a+b = 00000011
0040163D  COND: a = 00000008
00401641  COND: b = 00000009
00401643  COND: a+b = 00000011
0040163D  COND: a = 00000008
00401641  COND: b = 00000009
00401643  COND: a+b = 00000011
0040163D  COND: a = 00000008
00401641  COND: b = 00000009
00401643  COND: a+b = 00000011
0040163D  COND: a = 00000008
00401641  COND: b = 00000009
00401643  COND: a+b = 00000011
0040163D  COND: a = 00000008
00401641  COND: b = 00000009
00401643  COND: a+b = 00000011
0040163D  COND: a = 00000008
00401641  COND: b = 00000009
00401643  COND: a+b = 00000011
```
加法出现(省略进位的记录文件)，88888888080+9999999909=9888 8887 989

然后读取111111110100
```
00401708  COND: x = 00000000
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000000
00401708  COND: x = 00000000
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000000
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
00401708  COND: x = 00000000
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000000
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
00401708  COND: x = 00000001
0040170C  COND: y = 00000007
0040170F  COND: x*y = 00000007
```
111111110100*7=777777770700
7百位，即是输入的第3位
```
0040163D  COND: a = 00000000
00401641  COND: b = 00000009
00401643  COND: a+b = 00000009
0040163D  COND: a = 00000000
00401641  COND: b = 00000008
00401643  COND: a+b = 00000008
0040163D  COND: a = 00000007
00401641  COND: b = 00000009
00401643  COND: a+b = 00000010
0040163D  COND: a = 00000000
00401641  COND: b = 00000007
00401643  COND: a+b = 00000007
0040163D  COND: a = 00000007
00401641  COND: b = 00000008
00401643  COND: a+b = 0000000F
0040163D  COND: a = 00000007
00401641  COND: b = 00000008
00401643  COND: a+b = 0000000F
0040163D  COND: a = 00000007
00401641  COND: b = 00000008
00401643  COND: a+b = 0000000F
0040163D  COND: a = 00000007
00401641  COND: b = 00000008
00401643  COND: a+b = 0000000F
0040163D  COND: a = 00000007
00401641  COND: b = 00000008
00401643  COND: a+b = 0000000F
0040163D  COND: a = 00000007
00401641  COND: b = 00000008
00401643  COND: a+b = 0000000F
0040163D  COND: a = 00000007
00401641  COND: b = 00000009
00401643  COND: a+b = 00000010
```
9888 8887 989 + 7777 7777 0700 = 8766 6665 8689

接下来
```
1111111101000 * 6 = 6666666606000  6是千位，输入的第4位
8766 6665 8689 + 6666666606000 = 7543 3332 64689
11111111010000 * 5 = 55555555050000 5是万位，输入的第5位
7543 3332 64689 + 55555555050000 = 63098888314689
111111110100000 * 4 = 444444440400000  4是输入的第6位
63098888314689 + 444444440400000 = 507543328714689
1111111101000000 * 3 = 3333333303000000  3是输入的第7位
507543328714689 + 3333333303000000 = 3840876631714689
11111111010000000*2 = 22222222020000000
3840876631714689 + 22222222020000000 = 26063098651714689
111111110100000000*1=111111110100000000
26063098651714689 + 111111110100000000 = 137174208751714689
137174208751714689 * 9 = 1234567878765432201
```
算到这里过后，接下来就是关键的比较了

比较
```asm
00401154          |.  E8 47020000   |call    004013A0                        ;  获取计算后的长度
00401159          |.  25 01000080   |and     eax, 80000001
0040115E          |.  79 05         |jns     short 00401165
00401160          |.  48            |dec     eax
00401161          |.  83C8 FE       |or      eax, FFFFFFFE
00401164          |.  40            |inc     eax
00401165          |>  83F8 01       |cmp     eax, 1
00401168          |.  0F85 A7000000 |jnz     00401215
```
Call 004013A0由返回值eax=0x13可以知道，这里是获取计算后的长度，是0x13=19
长度和0x80000001做按位与，之后把返回值与1比较，不想等就跳转，这里不能跳转。
0x80000001按位与结果要为1，说明最低位也是1，即为奇数。
```asm
0040116E          |.  8D8C24 0C0100>|lea     ecx, dword ptr [esp+10C]
00401175          |.  E8 26020000   |call    004013A0                        ;  获取计算后长度
0040117A          |.  D1F8          |sar     eax, 1
0040117C          |.  50            |push    eax
0040117D          |.  8D8C24 100100>|lea     ecx, dword ptr [esp+110]
00401184          |.  E8 27020000   |call    004013B0                        ;  结果19位，取第19/2位
```
Call 004013A0是获取计算后的长度，然后除以2，这里长度是19，19/2=9.
Call 004013B0是获取计算后的第9位，下标从0开始，这里获取到8
```asm
00401189          |.  6A 00         |push    0
0040118B          |.  8D8C24 202100>|lea     ecx, dword ptr [esp+2120]
00401192          |.  8BF8          |mov     edi, eax
00401194          |.  E8 17020000   |call    004013B0                        ;  获取用户输入的第一位（9）
00401199          |.  3BF8          |cmp     edi, eax                        ;  比较
0040119B          |.  8D8C24 1C2100>|lea     ecx, dword ptr [esp+211C]
004011A2          |.  75 78         |jnz     short 0040121C
```
上面就是计算后的第9位和输入的第一位比较。
这里先修改一下jnz跳转，继续看下面的比较
```asm
004011A4          |.  6A 00         |push    0
004011A6          |.  E8 F5010000   |call    004013A0                             ;  用户输入的长度
004011AB          |.  48            |dec     eax
004011AC          |.  8D8C24 202100>|lea     ecx, dword ptr [esp+2120]
004011B3          |.  50            |push    eax
004011B4          |.  6A 01         |push    1
004011B6          |.  E8 E5010000   |call    004013A0                             ;  同上
004011BB          |.  BE 01000000   |mov     esi, 1
004011C0          |.  8D8C24 180100>|lea     ecx, dword ptr [esp+118]
004011C7          |.  2BF0          |sub     esi, eax
004011C9          |.  E8 D2010000   |call    004013A0                             ;  计算后的长度
004011CE          |.  03F0          |add     esi, eax
004011D0          |.  8D8C24 282100>|lea     ecx, dword ptr [esp+2128]
004011D7          |.  56            |push    esi
004011D8          |.  51            |push    ecx
004011D9          |.  8D8C24 200100>|lea     ecx, dword ptr [esp+120]
004011E0          |.  E8 FB010000   |call    004013E0                             ;  比较
004011E5          |.  6A 01         |push    1
004011E7          |.  8D8C24 202100>|lea     ecx, dword ptr [esp+2120]
004011EE          |.  8BF0          |mov     esi, eax
004011F0          |.  E8 AB010000   |call    004013A0
004011F5          |.  48            |dec     eax
004011F6          |.  8D9424 202100>|lea     edx, dword ptr [esp+2120]
004011FD          |.  50            |push    eax
004011FE          |.  6A 01         |push    1
00401200          |.  6A 00         |push    0
00401202          |.  52            |push    edx
00401203          |.  8D8C24 200100>|lea     ecx, dword ptr [esp+120]
0040120A          |.  E8 D1010000   |call    004013E0                             ;  比较
0040120F          |.  03F0          |add     esi, eax
00401211          |.  74 44         |je      short 00401257                       ;  关键跳转
```
Call 4013e0是比较的关键代码，调用了两次，同样可以记录一下每次比较的值，结果如下
```
0040145E  COND: a = 00000008
00401462  COND: b = 00000008
0040145E  COND: a = 00000007
00401462  COND: b = 00000007
0040145E  COND: a = 00000006
00401462  COND: b = 00000006
0040145E  COND: a = 00000005
00401462  COND: b = 00000005
0040145E  COND: a = 00000004
00401462  COND: b = 00000004
0040145E  COND: a = 00000003
00401462  COND: b = 00000003
0040145E  COND: a = 00000002
00401462  COND: b = 00000002
0040145E  COND: a = 00000001
00401462  COND: b = 00000001
0040145E  COND: a = 00000001
```
输入的2~9位与计算后的8~1位逐位比较
```
0040145E  COND: a = 00000001
00401462  COND: b = 00000001
0040145E  COND: a = 00000000
00401462  COND: b = 00000002
0040145E  COND: a = 00000002
00401462  COND: b = 00000003
0040145E  COND: a = 00000002
00401462  COND: b = 00000004
0040145E  COND: a = 00000003
00401462  COND: b = 00000005
0040145E  COND: a = 00000004
00401462  COND: b = 00000006
0040145E  COND: a = 00000005
00401462  COND: b = 00000007
0040145E  COND: a = 00000006
00401462  COND: b = 00000008
```
输入的第2~9位和计算后的12~19位逐位比较

## 算法总结：

输入：987654321->123456789
运算后：12345678 787 65432201
中间位等于输入的第一位
输入的第2~9位与计算后8~1比较
输入的第2~9位与计算后的12~19位比较

## 算法逆向

输入是8~20位，从8位开始穷举
结果是97654321

## 参考文章

[链接](http://bbs.pediy.com/thread-218181.htm)